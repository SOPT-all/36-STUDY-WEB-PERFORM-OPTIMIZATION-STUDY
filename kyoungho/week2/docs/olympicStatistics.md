
# 올림픽 통계 서비스 최적화

- ## 실습
    - *올림픽 통계 서비스*를 분석
      - 리우 올림픽과 런던 올림픽 정보를 사진과 함께 비교해 보여 주는 서비스
      - 하단에는 사용자 설문조사 결과를 막대 그래프로 표현, 항목 클릭 시 필터링 애니메이션이 적용됩 => 해당 애니메이션이 매끄럽지 않아 조금 끊기는 느낌
    - 최적화 기법
        - *CSS 애니메이션 최적화*를 통해 부드러운 화면 전환 구현
        - *컴포넌트 지연 로딩(lazy loading)* 으로 초기 로딩 속도 향상
        - *컴포넌트 사전 로딩(preloading)* 으로 사용자 경험의 끊김을 최소화
        - *이미지 사전 로딩(preloading images)* 으로 이미지 로드 지연을 방지

- ## 분석 툴
    - 크롬 *Network 패널* - 리소스 로드 타이밍을 한눈에 확인 가능
    - 크롬 *Performance 패널* - 메인 스레드 작업과 프레임 드롭 상황 모니터링 가능
    - *Webpack Bundle Analyzer* - 번들 파일 구조와 크기를 시각화하여 분석 가능

- ## 실습 - 서비스 분석
    - 실습  
        - 리포지터리 복제
            - `$ git clone https://github.com/performance-Lecture/Lecture-2.git`
        - 의존성 설치  
            - `$ npm install`
        - 서비스 실행
            - `$ npm run start`
        - API 서버 실행
            - `$ npm run server` - 백엔드(API) 서버 구동
        - `localhost:3000`로 서비스 구동
    - 서비스 설명
        - 단일 페이지로 구성, 상단에는 두 올림픽 이미지와 주요 정보가 표시
        - ‘올림픽 사진 보기’ 버튼을 클릭하면 모달이 팝업되어 사진을 캐러셀 형태로 표시
        - 화면 하단 영역에서 막대 그래프가 필터링 애니메이션을 통해 결과를 갱신
    - 폴더 구조  
        - `public/`  
        - `server/`  
            - `database.json`에 올림픽 데이터가 저장
        - `src/`  
            - `assets/`에 이미지 파일이 있고,
            - `components/`에는 `Header.js`, `ImageModal.js`, `SurveyChart.js` 등 핵심 컴포넌트가 모여 있습니다

- ## 애니메이션 최적화
    - 설문조사 막대 그래프의 애니메이션이 부드럽지 않고 가끔 끊기는 느낌이 듭니다.  
	- ==Performance 패널에서 CPU를 느리게(6x slowdown) 설정==을 통해 확실하게 확인 가능
    - 브라우저 렌더링 과정 이해  
        - HTML 파싱 → *DOM* 트리 생성  
        - CSS 파싱 → *CSSOM* 트리 생성  
        - DOM + CSSOM → *렌더 트리* 구성  
        - *Layout* 단계에서 요소 위치와 크기를 계산  
        - *Paint* 단계에서 색을 입힘  
        - *Composite* 단계에서 레이어를 합성  
    - 리플로우(Reflow)와 리페인트(Repaint)  
        - `width`, `height` 등 레이아웃 속성 변경 시 전체 경로를 재실행하며 리소스를 많이 소모합니다.  
        - **`color`, `background-color` 등 페인트 속성 변경 시 레이아웃 단계는 생략되지만 여전히 비용이 크다**
    - 하드웨어 가속 활용  
        - *transform*과 *opacity* 속성은 GPU로 처리되어 레이아웃과 페인트 단계를 건너뛸 수 있습니다.  
        - `scaleX`를 사용해 너비 애니메이션을 구현, `transform-origin: center left`로 기준점을 정하면 자연스러운 효과 구현이 가능
    - 최적화 전·후 비교  
        - 최적화 전 -> 레이아웃과 페인트 작업이 60FPS 내에 끝나지 않아 프레임 드롭이 발생
        - 최적화 후 -> 레이아웃·페인트가 생략되어 메인 스레드 여유가 생긴 것을 확인

- ## 컴포넌트 지연 로딩
    - 초기 로딩 시 모달과 *react-image-gallery* 라이브러리는 불필요하므로 번들에서 분리하는 것이 효율적이다
    - 상세 구현 방법  
        - React의 `lazy`와 `Suspense`를 활용하여 `ImageModal` 컴포넌트를 동적으로 로드
        - 로딩 전 `fallback={null}`을 설정해 빈 화면으로 처리 
    - 결과  
        - 초기 번들에서 `react-image-gallery`와 `ImageModal` 코드가 분리되어 두 개의 청크로 나뉘었고,
        - ‘올림픽 사진 보기’ 클릭 시 네트워크 패널에서 두 청크가 차례로 로드되는 것 확인 가능
        - 번들 분석 결과 약 52KB가 분리되었지만 그럼에도 초기 로딩 성능은 확실히 개선된 것이 체감 가능하였습니다

- ## 컴포넌트 사전 로딩
    - ==지연 로딩의 한계==  -> 모달을 띄우는 순간 네트워크 요청이 추가로 발생해 사용자 경험이 끊길 수 있음
    - **사전 로딩(preloading) 기법**  
        - `onMouseEnter` 이벤트에서 `import()`를 호출해 버튼에 마우스를 올리는 순간 미리 모달 코드를 로드
        - 또는 `useEffect` 훅에서 컴포넌트 마운트 후 백그라운드로 모달 청크를 불러오는 방법도 있습니다
    - **타이밍 고려**  
        - 버튼에 마우스를 올리는 시점 -> 클릭 전 약 300~600ms 동안 충분히 로드가 가능
        - 마운트 완료 후 -> 초기 로딩 직후 브라우저가 한가할 때 미리 로드
        - 서비스 특성에 맞춰 가장 자연스러운 타이밍을 선택하는 것이 중요

- ## 이미지 사전 로딩
    - 모달 오픈 직후 이미지가 늦게 뜨면서 빈 화면이 보여지는 UX 이슈가 있었음
    - 구현 방법  
        - JavaScript `Image` 객체를 생성해 `new Image().src = 이미지_URL`로 사전 다운로드를 시작
        - `ImageModal.js`의 `useEffect`에 코드를 추가
	- ‘Disable cache’ 옵션 해제 후 ‘캐시 비우기 및 강력 새로고침’으로 테스트해야 정확한 로드 시간 확인 가능
	- 브라우저 캐시를 활용하므로 최초 로드 시만 네트워크 요청이 발생
---

## 코드 분석

### 1. 폴더 구조
- 폴더 구조는 다음과 같다
    - public
    - server  
        - config.json  
        - database.json  # 올림픽 통계 서비스의 데이터베이스 파일
    - src  
        - assets  # 이미지 파일 모음
            - btn-close.png  
            - london-2012.jpg  
            - Tondon-flag.png  
            - rio-2016.jpg  
            - rio-flag.jpeg  
        - components  # 재사용 가능한 컴포넌트들
            - Bar.js  # 설문 결과 그래프 막대 컴포넌트
            - Footer.js  # 푸터 컴포넌트
            - Header.js  # 상단 헤더 컴포넌트
            - ImageModal.js  # 사진 모달 컴포넌트
            - InfoTable.js  # 올림픽 정보 테이블 컴포넌트
            - SurveyChart.js  # 설문 결과 차트 컴포넌트
            - SurveyItem.js  # 개별 설문 항목 컴포넌트
        - App.js  # 메인 앱 컴포넌트
        - index.css  # 전역 스타일 시트
        - index.js  # 엔트리 포인트
    - README.md  
    - package-lock.json  
    - package.json  # API 서버 실행 설정 파일

### 2. App 컴포넌트(src/App.js)
- *ImageModal*
    - `showModal` state가 false일 때는 모달이 화면에 렌더링되지 않는다
    - `showModal`이 true로 변경되면 모달이 나타나는데, 이 간단한 로직이 추후 최적화 지점이 될 것
- 모달이 처음에 렌더되지 않는다는 점 -> 추후 Lazy Mounting이나 코드 스플리팅 시 고려
- 추가로 전역 스타일 적용 상태나 Context API 사용 여부를 이 파일에서 확인 가능할 것 

### 3. ImageModal 컴포넌트(src/components/ImageModal.js)
- *react-image-gallery* 외부 라이브러리를 사용하고 있음
	- 해당 라이브러리에 이미지 데이터 배열을 넘겨 갤러리 형태로 렌더링
- 외부 라이브러리 도입 시 번들 사이즈 증가가 불가피하여 로딩 속도에 영향이 있을 것
    - 자바스크립트 번들 크기가 커지면 초기 로딩 시간이 길어질 수 있다  
    - 이미지 로딩 지연으로 사용자 경험이 저하될 수도 있음
- 최적화 방향?
    - React.lazy와 Suspense를 활용한 코드 분할(Code Splitting)  
    - Intersection Observer로 이미지 지연 로딩(lazy-loading) 구현  
    - 서버 사이드 렌더링(SSR)을 통해 초기 콘텐츠를 빠르게 노출  

### 4. Bar 컴포넌트(src/components/Bar.js)
- 막대 그래프를 그리는 컴포넌트
    - styled-components로 `BarGraph` UI를 구현 중
    - `width` 속성에 `percent` props를 바인딩하고, `transition`을 통해 애니메이션을 적용
- 브라우저 렌더링 원리에 따르면 `width`가 바뀔 때마다 레이아웃 리플로우가 발생하여 성능 이슈가 있을 것
    - 특히 응답 수가 많아지면 프레임 드랍이 발생할 가능성이 커짐 
- 최적화 방향?
    - CSS transform(`scaleX()`)을 사용해 레이아웃 변경을 최소화  
    - `will-change` 속성으로 브라우저에게 미리 힌트를 주기  
    - Canvas나 WebGL 기반 차트 라이브러리 도입
---
## 애니메이션 최적화

- 사용자 경험을 높이기 위해 웹 애니메이션을 부드럽게 만들고 끊김을 줄여야 함
- 올림픽 통계 서비스 설문 결과 영역에 있는 애니메이션은
    - 클릭 시 응답 필터링이 이루어짐
    - 막대 그래프의 배경색과 가로 길이가 변경
- UI 설계할 때 애니메이션 부드러움은 사용자의 몰입감과 직결될 수 있습니다
- 작은 버벅임도 서비스 만족도를 크게 떨어뜨릴 수 있습니다  

### 문제의 애니메이션

- 설문 결과 애니메이션을 보면 가로 막대가 부드럽게 늘어나지 않고  살짝 끊기는 느낌이 듦
- 성능 좋은 컴퓨터에서는 잘 느껴지지 않을 수 있지만  
    - 개발자 도구 Performance 탭에서 CPU를 *6x slowdown*으로 설정하면 확실히 보입니다  
- 이런 끊김 현상을 *쟁크(jank)* 라고 부
	- *실제 프로젝트를 진행하면서 작은 버벅임도 사용자 불편으로 이어진다는 걸 많이 느꼈습니다*  

### 애니메이션의 원리
- 애니메이션은 여러 장의 이미지를 빠르게 전환하며 잔상을 남기는 방식으로 움직임을 표현합니다  
    - 프레임 하나라도 빠지면 어색하게 끊기는 느낌이 납니다  
- 대다수 모니터 주사율은 *60Hz*, 브라우저는 초당 *60FPS*로 화면을 그립니다  
    - CPU나 렌더링 단계에서 병목이 생기면 40FPS, 20FPS로 떨어지면서 끊김이 발생합니다  
- 브라우저 렌더링 파이프라인 주요 단계  
    - **스타일 계산** -> CSS를 해석해 각 요소의 스타일을 결정합니다  
    - **레이아웃** -> 요소의 크기와 위치를 계산합니다  
    - **페인트** -> 계산된 스타일대로 픽셀을 화면에 그립니다  
    - **컴포지트** -> 그려진 레이어를 합쳐 최종 화면을 완성합니다  
- 이 중 어느 단계에서든 병목이 생기면 프레임이 누락되어 애니메이션 jank가 발생 
---
## 브라우저 렌더링 과정

- 브라우저는 화면을 그리기 위해 여러 단계를 거치며, 해당 과정을 *DOM 생성*부터 *컴포지트*까지 차례로 진행

- **1) DOM 생성**  
    - HTML을 파싱하여 요소 간의 관계를 트리 구조로 표현합니다.  
	    - 이렇게 만들어진 구조를 *Document Object Model*이라고 부릅니다.  
- **2) CSSOM 생성**  
    - CSS 파일을 파싱해 스타일 정보를 담은 트리를 만듭니다.  
    - *CSS Object Model*에는 각 요소가 어떤 스타일을 가질지 정보가 정리됩니다.  
- **3) 렌더 트리 구성**  
    - DOM과 CSSOM을 결합해 실제 화면에 그릴 요소만 추려서 트리를 만듭니다.  
    - `display: none`인 요소는 제외되고, `visibility: hidden`이나 `opacity: 0`은 포함됩니다.  
- **4) 레이아웃 계산**  
    - 렌더 트리를 바탕으로 각 요소의 위치와 크기를 계산합니다.  
- **5) 페인트 단계**  
    - 배경색, 글자색, 테두리 등 실질적인 색상 값을 화면에 채워 넣습니다.  
    - 브라우저는 효율을 위해 여러 *레이어*로 분리해 작업하기도 합니다. 
- **6) 컴포지트 단계**  
    - 페인트된 레이어들을 하나로 합성해 최종 화면을 만듭니다.  
	    - -> 최종적으로 우리가 보는 페이지가 완성

## 실습으로 확인

- Performance 패널에서  
    - Parse HTML, Layout, Paint 등의 작업 이름으로 단계별 소요 시간을 볼 수 있습니다.  
    - 회색 세로 점선은 브라우저가 초당 최대 60번 화면을 갱신하는 시점을 표시합니다.  

## 리플로우와 리페인트

- **리플로우(Reflow)**  
    - 요소의 너비나 높이 등 *레이아웃 관련 속성*이 바뀔 때 발생합니다.  
    - CSSOM → 렌더 트리 → 레이아웃 → 페인트 → 컴포지트, 모든 단계를 다시 실행합니다.  
    - 리소스를 많이 쓰기 때문에 가능한 적게 일어나게 하는 게 좋습니다.  

- **리페인트(Repaint)**  
    - 글자색(color)이나 배경색(background-color) 같은 *비레이아웃 속성*이 바뀔 때 생깁니다.  
    - 레이아웃 단계를 건너뛰고 페인트 → 컴포지트만 실행합니다.  
    - 리플로우보다는 가볍지만 여전히 비용이 꽤 듭니다.  

## 하드웨어 가속 (GPU 가속)

- CPU 대신 GPU에 그래픽 작업을 맡겨 속도를 높이는 방법입니다.  
	- GPU는 원래 화면 그리기에 최적화돼 있어서 훨씬 빠릅니다.  

- 적용 방법  
    - `transform`, `opacity` 같은 속성을 사용해 요소를 별도 레이어로 분리합니다.  
	    - -> 이렇게 하면 레이아웃·페인트 단계를 건너뛰고 곧바로 컴포지트만 수행할 수 있습니다.
	    - -> 그 결과 애니메이션 시 *프레임 드랍* 없이 부드럽게 동작

## 막대 그래프 애니메이션
- **width 변경 방식**  
    - 막대 그래프의 `width`를 직접 조절하면 매 프레임마다 리플로우가 발생합니다.  
    - CPU 자원이 부족해지면 화면 갱신이 제때 안 돼서 *쟁크* 현상이 생깁니다.  
- **GPU 가속 방식**  
    - `transform: scaleX(…)` 같은 속성을 활용하면 리플로우 없이 처리할 수 있습니다.  
    - Performance 패널로 확인해보면 레이아웃 단계가 사라지고 컴포지트만 실행되는 것 확인 가능

---
## 애니메이션 최적화
- *width*로 애니메이션을 처리하면 브라우저가 레이아웃과 페인트를 다시 수행해야 합니다.  
    - -> 이 과정에서 CPU에 부담이 커지고 프레임 드롭 위험이 높아짐
- 경량화 방법: *transform* 사용  
    - transform 속성 종류  
        - *translate*: 위치 이동  
        - *scale*: 크기 변경  
        - *rotate*: 회전  
    - 막대 그래프에서는 *scaleX*를 활용해 가로 비율만 조절
- **BarGraph 구현 예시**  
    - 초기 스타일 설정  
        - width: 100%  
        - transform-origin: left center  
    - 애니메이션 코드  
        ```js
        // widthPercent는 0~100 사이 값입니다.
        const factor = widthPercent / 100;
        element.style.transform = `scaleX(${factor})`;
        ```  
    - 동작 방식  
        - factor가 0이면 막대가 완전히 사라집니다
        - factor가 1이면 막대가 100% 너비로 유지됩니다
    - 주의 사항  
        - 기본 transform-origin이 중앙(center)이므로 반드시 left center로 변경해야 합니다.  
- 기대 효과  
    - 레이아웃/페인트 작업 생략으로 메인 스레드 부하 감소  
    - GPU 가속 레이어 생성으로 부드러운 애니메이션 구현  
    - 모바일 환경에서도 안정적인 성능 유지  

### 최적화 전후 비교
- **최적화 전 메인 스레드**  
    - 레이아웃과 페인트 작업이 동시에 실행되어 CPU 부하가 높았으며
    - 프레임 드롭은 없었지만 작업이 상당히 아슬아슬하게 완료됩니다
	    - -> 성능이 낮은 기기에서는 애니메이션이 끊길 가능성이 큽니다
- **최적화 후 메인 스레드**  
    - 레이아웃/페인트 작업이 제거되어 타임라인에 여유가 생겼고
    - 캡처된 타임라인 상에서도 이전보다 훨씬 부드럽게 보입니다.
- 또한 DevTools에서 FPS 차트를 직접 확인해 보시면 차이가 더 크게 느껴짐
---
## 컴포넌트 지연 로딩
- 컴포넌트 지연 로딩은 *필요한 순간*에만 컴포넌트를 불러와 초기 로딩 속도를 높이는 기법입니다
	- *이전 챕터에서 블로그 서비스에 적용했던 방법처럼 페이지 전환 시 필요한 코드만 로드하도록 설정*
### 번들 파일 분석
- *cra-bundle-analyzer*로 번들 구조를 파악
    - 설치
        - `npm install --save-dev cra-bundle-analyzer`
    - 실행
        - `npx cra-bundle-analyzer`
- 시각화된 결과를 보면 두 가지 큰 청크로 나뉘어 있음
    - 왼쪽 청크
        - node_modules 라이브러리 코드(react, styled-components 등)
    - 오른쪽 청크
        - 올림픽 통계 서비스의 자체 코드
- 특히 *react-image-gallery* 라이브러리가 약 26KB를 차지하고 있는데 이 코드는 사진 갤러리 모달에서만 쓰일 것 같음
	- 사용자 입장에서는 첫 화면에 이만큼의 코드를 기다리지 않아도 되니 체감 속도가 꽤 빨라질 것으로 기대

### 모달 코드 분리하기
- App.js에서 ImageModal 컴포넌트를 지연 로드하도록 수정
    - React.lazy와 Suspense 불러오기
        - `import { lazy, Suspense } from 'react';`
    - 동적 import 설정
        - `const ImageModal = lazy(() => import('./ImageModal'));`
    - 기존 직접 import 구문은 주석 처리
- Suspense로 로딩 상태를 처리
    - *`fallback`에 스피너나 스켈레톤 UI를 넣으면 사용자 경험이 더 좋아질 것 같습니다.*
- 브라우저 네트워크 패널에서 동작을 확인
    - 첫 페이지 로딩 시 핵심 청크만 내려받
    - '올림픽 사진 보기' 버튼 클릭 시 ImageModal과 react-image-gallery 청크가 추가로 로드
- cra-bundle-analyzer로 재분석해 보면 청크가 별도 분리된 것 확인 가능
    - react-image-gallery와 의존성 라이브러리가 함께 묶여 총 약 52KB 분리되었습니다
- 결과
    - 초기 로딩 속도가 개선되어 사용자 만족도가 높아짐
    - 이후 모달에 더 많은 콘텐츠나 라이브러리가 추가되더라도 유연하게 대응 가능
	    - 하지만 반대로 청크 개수가 너무 많아지면 관리 포인트가 늘어나니 적절한 분할 단위 고민 필요
- Skeleton UI를 활용해 로딩 느낌을 줄이면 사용자 경험이 더욱 개선 가능할 것 같습니다
- 서버 사이드 렌더링(SSR) 환경에서는 React.lazy가 동작하지 않음
- webpack의 SplitChunksPlugin 옵션을 조정해 더욱 세밀한 코드 분할이 가능
- ErrorBoundary를 도입해 컴포넌트 로딩 중 에러가 발생해도 대처가 가능
---

## 컴포넌트 사전 로딩

### 지연 로딩의 단점
- *지연 로딩* 기법을 적용해 보니 초기에 모달 코드를 번들에서 제외해서  
    - 번들 크기가 줄고  
    - 초기 로딩 속도와 자바스크립트 실행 타이밍이 빨라져 화면이 더 빨리 표시
- 하지만 실제로 모달을 띄울 때는 
    - 네트워크를 통해 모달 코드를 다시 받아야 해서  
    - 클릭 시점과 렌더링 시점 사이에 약간의 딜레이가 생기는 것 같았습니다
- Performance 패널로 확인시
    - Network Throttling을 'Fast 4G'로 설정하고  
    - 페이지가 모두 로드된 상태에서 '올림픽 사진 보기' 버튼을 클릭하니  
    - 일정 시간 뒤에야 모달이 뜨는 것 확인 가능하였음

### 사전 로딩(Preloading) 기법
- *사전 로딩*은 나중에 필요할 모듈을 미리 로드해 두는 방법입니다 -> 이렇게 하면 클릭하자마자 모달이 뜨는 효과가 가능
- 언제 모듈을 미리 로드할지 결정할 수 있어야 함
	- -> 지나치게 많은 모듈을 미리 로드하면 초기 네트워크 트래픽 부담이 커질 수 있음

### 컴포넌트 사전 로딩 타이밍
- 버튼 위에 마우스 올려놓았을 때  
    - PC 웹에서 버튼 클릭 전에는 반드시 마우스를 올려야 하므로  
    - `onMouseEnter` 이벤트를 활용하면 모달 코드를 미리 로드할 수 있습니다.  
    - **예제 코드**  
        ```jsx
        import React, { lazy } from 'react';

        const ImageModal = lazy(() => import('./ImageModal'));

        function Button() {
            const handleMouseEnter = () => {
                import('./ImageModal');
            };
            return <button onMouseEnter={handleMouseEnter}>올림픽 사진 보기</button>;
        }
        ```
    - 실제 서비스에서 확인해 보니,  
        - 버튼 위에 커서를 올리기만 해도 모달 관련 파일이 바로 로드되었고  
        - 클릭 시 300~600ms 정도 여유
- 모든 컴포넌트 마운트 완료 후  
    - 컴포넌트가 다 마운트된 뒤 여유 시간에 모듈을 로드하는 방법입니다  
    - 클래스형은 `componentDidMount`, 함수형은 `useEffect` 시점에 적용 가능
    - **예제 코드**  
        ```jsx
        import { useEffect } from 'react';

        function App() {
            useEffect(() => {
                import('./ImageModal');
            }, []);
            return <div>앱 내용</div>;
        }
        ```
    - Waterfall 확인 결과  
        - 초기 페이지 로드에 필요한 파일(O.chunk.js, bundle.js)을 먼저 받고  
        - 페이지 로드가 완료된 후에 모달 관련 청크(2.chunk.js, 3.chunk.js)가 다운로드
- 모달 컴포넌트 크기가 크면 더 일찍 로드해야 할 수도 있습니다.  
- 사용자 행동 패턴을 분석해 최적의 타이밍을 결정하는 것이 좋을 것 같습니다.  
- 서비스 특성과 UX 요구 사항을 충분히 고려해야 합니다.
---
## 이미지 사전 로딩

### 느린 이미지 로딩
- 웹 모달에서 이미지가 *느리게 뜨는* 현상이 종종 발생
    - **처음엔 빈 화면이다가 나중에 이미지가 나타나는 현상**
    - 확인 방법  
        - 개발자 도구 네트워크 패널에서 속도 제한(throttling)을 설정
        - *Disable cache* 옵션을 켜서 캐시를 완전히 비활성화해야 확실히 테스트가 가능
- 원인 분석  
    - 이미지 파일 용량이 크면 다운로드 시간이 오래 걸려서 지연이 생깁니다  
    - 모달을 띄운 뒤에 이미지를 요청하기 때문에 초기 화면이 공백으로 남는 것 같습니다  
- 대응 방안  
    - 자바스크립트로 이미지 *사전 로딩* 기법을 적용
    - 다른 최적화 기법도 있지만 JS 기반 방식을 중점적으로 적용

### 이미지 사전 로딩
- 기본 로딩 방식  
    - HTML이나 CSS에서 이미지를 사용하는 시점에 로드됩니다  
    - 이 방식은 이미지가 표시될 때까지 기다려야 해서 지연이 발생합니다  
- 자바스크립트로 미리 다운로드하기  
    - *Image 객체* 사용법  
        ```js
        const img = new Image();
        img.src = 'https://example.com/image.jpg';
        ```  
    - 위 코드를 브라우저 콘솔에 입력하면 네트워크 패널에서 즉시 이미지가 다운로드되는 걸 확인할 수 있습니다  
- 실제 코드 적용 예시  
    - 사전 로드 대상: 모달에서 가장 먼저 보이는 대표 이미지  
    - 이미지 주소: `ImageModal.js` 파일에서 확인했습니다  
    - 코드 삽입 위치: *useEffect* 훅 내부에 추가합니다  
    - **예제 코드**  
        ```js
        useEffect(() => {
            const preloadedImg = new Image();
            preloadedImg.src = modalImageUrl;
        }, []);
        ```  
    - 이렇게 하면 페이지가 로드될 때 백그라운드에서 이미지를 미리 다운받아 줍니다  
- 캐시 설정에 유의해야 합니다  
		- 개발자 도구에서 *Disable cache* 옵션을 꺼 놓고 테스트합니다  
		- 새로고침 시에는 일반 새로고침 대신 *캐시 비우기 및 강력 새로고침*을 사용해야 정확한 결과를 볼 수 있습니다  
- 모달을 열어 보면 대표 이미지가 즉시 보이는 것을 확인할 수 있습니다  
	- -> 네트워크 속도 제한을 적용하면 효과가 더 확실히 체감될 것입니다  
- 결과 확인  
    - 네트워크 패널 Size 열에 *disk cache*로 표시되며 다운로드 시간이 거의 0ms에 가까워짐
	    - -> 페이지 로드와 동시에 이미지가 이미 준비돼 있어서
- 추후 고려 사항  
    - 몇 장의 이미지를 사전 로드할지 결정해야 합니다  
        - 대표 이미지 외에 하단 섬네일까지 모두 로드하면 초기 리소스 사용량이 늘어날 수 있습니다  
        - 실제 프로젝트에서는 우선순위를 고려해 로드 범위를 조절하는 것이 좋습니다  

