# 4주차 (144~179)

## 트러블슈팅
**Node.js 버전 호환성 문제** 발생

---
### 오류 분석
**오류 메시지**: `Error: error:0308010C:digital envelope routines::unsupported`
**원인**:
- 현재 Node.js 버전 22.16.0 (최신 버전) 사용
- 프로젝트 사용 `react-scripts@4.0.3` 및 `webpack@4.44.2`는 구버전
- 해당 구버전들은 최신 Node.js (17+ 부터 기본값인 OpenSSL 3.0)에서 제거된 레거시 암호화 알고리즘을 사용해서 오류 발생

### 오류 해결
`package.json`의 start 스크립트를 다음과 같이 수정
```json
{
  "scripts": {
    "start": "NODE_OPTIONS='--openssl-legacy-provider' react-scripts start"
  }
}
```

## 동영상 최적화
### 동영상 콘텐츠 분석(pg.144)
1. 홈페이지에 사용된 동영산은 메인 페이지에 배경으로 등장하는 영상입니다.
	1. Network 패널에서 동영상이 다운로드되는 과정을 살펴봄
	2. 동여상 파일은 이미지처럼 하나의 요청으로 모든 영상을 다운로드 하지 않음
	3. 동영상 콘텐츠의 특성상 파일 크기가 크기 때문에 당장 재생이 필요한 앞부분을 먼저 다운로드한 뒤 순차적으로 나머지 내용을 다운로드
	4. 결과적으로 동영상 컨텐츠의 다운로드 요청은 여러 개로 나누어지게 됨

#### 문제 상황
여러 번 나눠서 다운로드를 해도 애초 영상 파일이 큽니다 -> 동영상 재생까지 오래 걸립니다.
	이는 performance 패널을 통해 확인이 가능합니다.
동영상 파일이 54mb인데 이는 웹에서 사용하기엔 영상이 너무 큽니다.

웹페이지에서 영상이 어떻게 불러와져서 표현되는지도 알게 되었고, 문제 상황도 인지하였습니다. 그렇다면 재생까지 오래 걸림 + 크기가 너무 큰 문제를 어떻게 해결해야 할까요?

### 동영상 압축(pg.146)
동영상 압축을 적용합니다. 동영상 압축은 이미지 최적화와 비슷하며, 동영상의 가로와 세로 사이즈를 줄이고, 압축 방식을 변경하여 영상 크기를 줄이는 방식입니다.

### But..
이 작업은 동영상의 화질을 낮추는 작업입니다. 따라서 서비스의 목적에 따라서 사용할지 말지를 선택해야 합니다.

동영상을 WebM으로 변환, (WebM은 WebP와 동일하게 구글에서 개발한 동영상 포맷입니다)
동영상 최적화의 의의는 압축하여 크기를 줄이는데에 있으니 어떤 툴을 사용해도 상관 없으리라 생각했습니다.

 **FFmpeg**라는 동영상 변환 및 압축 도구를 사용해서 명령어로 진행하였습니다.   

### 변환 명령어

```bash

ffmpeg -i banner-video.mp4 -c:v libvpx-vp9 -crf 30 -b:v 0 -b:a 128k -c:a libopus banner-video.webm

```

  ### 사용된 옵션
- `-c:v libvpx-vp9`: VP9 비디오 코덱 사용 (WebM의 최신 코덱)
- `-crf 30`: Constant Rate Factor 30 (품질과 압축률의 균형)
- `-b:v 0`: 비디오 비트레이트를 CRF에 의해 자동 결정
- `-b:a 128k`: 오디오 비트레이트 128kbps
- `-c:a libopus`: Opus 오디오 코덱 사용

### 최적화 결과

| 구분     | 원본 (MP4)  | 최적화 (WebM) | 개선율    |
| ------ | --------- | ---------- | ------ |
| 파일 크기  | 52MB      | 27MB       | 48% 감소 |
| 비디오 코덱 | H.264     | VP9        | -      |
| 오디오 코덱 | -         | Opus       | -      |
| 해상도    | 1920x1080 | 1920x1080  | 동일     |
| 프레임레이트 | 29.97fps  | 29.97fps   | 동일     |

### 패턴과 필터 적용
패턴과 필터를 이용하면 낮은 화질을 조금이나마 보완이 가능하지만, 이는 일종의 착시나 심리적 보완을 이용하는 방법입니다.

---
## 폰트 최적화(pg.151)
웹 페이지에서 사용자 정의 폰트를 사용할 때, 폰트 파일 다운로드에 시간이 소요되어 다음과 같은 문제가 발생할 수 있습니다.

### 문제 상황
웹 폰트 로딩 지연과 사용자 경험 저하


1. **텍스트 깜빡임 (FOUT/FOIT)**
    - 폰트가 로드되기 전까지 기본 폰트로 표시되거나(FOUT), 텍스트가 아예 보이지 않다가(FOIT) 폰트 로드 후 갑자기 나타나는 현상
	    - 이는 사용자에게 페이지가 느리다는 인상을 주거나, 
	    - 레이아웃 변경(Layout Shift)을 유발하여 사용성을 해침
2. **FOUT (Flash of Unstyled Text) 와 FOIT (Flash of Invisible Text)**
    - **FOUT:*
	    - 폰트 다운로드 여부와 관계없이 우선 텍스트를 기본 폰트로 보여주고, 
	    - 폰트 다운로드 완료 시 적용 (Edge 브라우저 방식)
    - **FOIT**
	    - 폰트가 완전히 다운로드될 때까지 텍스트를 보여주지 않음 (Chrome, Safari, Firefox 등)
        - **Chrome의 FOIT**
	        - 3초 동안 폰트 로드를 기다리며, 3초 초과 시 기본 폰트로 우선 표시 후 폰트 다운로드 완료 시 적용

### 폰트 최적화 주요 방법
폰트 최적화는 크게 **폰트 적용 시점 제어**와 **폰트 파일 크기 줄이기** 두 가지 방법으로 나눌 수 있습니다.

#### 1. 폰트 적용 시점 제어
CSS의 `@font-face` 내 `font-display` 속성을 사용하여 폰트 렌더링 방식을 제어할 수 있습니다.

- **`font-display` 속성 값**
    - `auto`
	    - 브라우저 기본 동작 (기본값)
    - `block`
	    - FOIT 방식 (일반적으로 3초 타임아웃)
	    - 텍스트가 보이지 않다가 폰트 로드 후 표시
    - `swap`
	    - FOUT 방식
	    - 기본 폰트로 우선 표시 후 폰트 로드 시 교체
    - `fallback`
	    - 짧은 시간(약 0.1초) 동안 FOIT
		- 실패 시 기본 폰트 사용
		- 이후 폰트가 다운로드되면 다음 방문 시 캐시된 폰트 사용 (첫 로드 시에는 늦게 로드된 폰트 미적용)
    - `optional`
	    - 짧은 시간(약 0.1초) 동안 FOIT
	    - 네트워크 상태에 따라 폰트 적용 여부 결정. 다운로드되지 않으면 기본 폰트 사용, 이후 캐시
- 콘텐츠의 중요도에 따라 적절한 값을 선택해야 합니다. 
	- 예를들어 중요하지 않은 텍스트는 `block` 사용

#### 2. 폰트 파일 크기 줄이기
폰트 파일 크기를 줄여 다운로드 시간을 단축합니다.

- **방법 1: 최신 폰트 포맷 사용**
    - 기존 포맷 (TTF, OTF)은 웹 환경에서 크기가 큼
    - 웹 전용 포맷:
        - **WOFF (Web Open Font Format)** 
	        - TTF를 압축하여 웹 로딩 속도 개선
        - **WOFF2** 
	        - WOFF보다 압축률이 더 향상된 포맷
    - 파일 크기 순서 (큼 → 작음): EOT > TTF/OTF > WOFF > WOFF2
    - **브라우저 호환성** 
	    - 최신 브라우저는 WOFF/WOFF2를 잘 지원
	    - 하지만 하위 호환성을 위해 여러 포맷을 함께 제공하는 것이 좋음 (WOFF2 → WOFF → TTF 순으로 적용)
- **방법 2: 필요한 문자만 포함 (서브세팅)**
    - 폰트 파일에서 실제 사용하는 문자들만 추출하여 파일 크기를 대폭 줄이는 방식
- **방법 3: Data-URI 활용**
    - 폰트 파일을 Base64 등으로 인코딩하여 문자열 형태로 CSS 파일 내에 직접 삽입
    - **장점** 
	    - 폰트를 위한 별도의 HTTP 요청이 발생하지 않아 로딩 속도 개선 (CSS 파일 로드 시 함께 로드됨)

---

## 캐시 최적화(pg.165)

### 문제: 효율적인 캐시 정책의 부재

웹 페이지 로딩 성능 분석 시 "Serve static assets with an efficient cache policy" 항목은 정적 리소스에 캐시 정책이 제대로 적용되지 않았음을 의미합니다. 

개발 서버(`npm run start` 등)는 기본적으로 캐시 설정을 제공하지 않아 응답 헤더에 `Cache-Control` 같은 캐시 관련 헤더가 누락될 수 있습니다.

### 1. 캐시란 무엇인가?
- 자주 사용하는 데이터나 값을 미리 복사해 둔 임시 저장 공간, 또는 그 저장 행위.
- **웹에서의 역할** 
	- 이미지, JS, CSS 파일 등을 최초 요청 시 다운로드하여 캐시에 저장하고, 이후 동일 요청에는 저장된 파일을 사용하여 네트워크 트래픽 감소 및 로딩 속도 향상.
- **웹 캐시의 종류**
    - **메모리 캐시 (Memory Cache)** 
	    - RAM에 저장
	    - 브라우저가 열려있는 동안 매우 빠르게 접근 가능
	    - 탭을 닫거나 브라우저 종료 시 사라짐
    - **디스크 캐시 (Disk Cache)** 
	    - 하드 디스크에 파일 형태로 저장
	    - 브라우저를 종료했다 다시 실행해도 사용 가능
	    - 메모리 캐시보다 느리지만 영속적
    - 어떤 캐시를 사용할지는 브라우저가 자체 알고리즘(사용 빈도, 파일 크기 등)에 따라 결정
    - 개발자 도구 Network 패널의 "Disable cache" 옵션을 해제해야 캐시 동작 확인 가능

### 2. 캐시 제어: `Cache-Control` 헤더
브라우저가 리소스를 캐시하려면 서버 응답 헤더에 `Cache-Control` 헤더가 포함되어 있어야 합니다.

이 헤더는 캐시의 동작 방식과 유효 기간을 지정합니다.