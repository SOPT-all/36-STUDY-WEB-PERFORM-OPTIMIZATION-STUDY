# 4주차 (144~179)

## 트러블슈팅
**Node.js 버전 호환성 문제** 발생

---
### 오류 분석
**오류 메시지**: `Error: error:0308010C:digital envelope routines::unsupported`
**원인**:
- 현재 Node.js 버전 22.16.0 (최신 버전) 사용
- 프로젝트 사용 `react-scripts@4.0.3` 및 `webpack@4.44.2`는 구버전
- 해당 구버전들은 최신 Node.js (17+ 부터 기본값인 OpenSSL 3.0)에서 제거된 레거시 암호화 알고리즘을 사용해서 오류 발생

### 오류 해결
`package.json`의 start 스크립트를 다음과 같이 수정
```json
{
  "scripts": {
    "start": "NODE_OPTIONS='--openssl-legacy-provider' react-scripts start"
  }
}
```

## 동영상 최적화
### 동영상 콘텐츠 분석(pg.144)
1. 홈페이지에 사용된 동영산은 메인 페이지에 배경으로 등장하는 영상입니다.
	1. Network 패널에서 동영상이 다운로드되는 과정을 살펴봄
	2. 동여상 파일은 이미지처럼 하나의 요청으로 모든 영상을 다운로드 하지 않음
	3. 동영상 콘텐츠의 특성상 파일 크기가 크기 때문에 당장 재생이 필요한 앞부분을 먼저 다운로드한 뒤 순차적으로 나머지 내용을 다운로드
	4. 결과적으로 동영상 컨텐츠의 다운로드 요청은 여러 개로 나누어지게 됨

#### 문제 상황
여러 번 나눠서 다운로드를 해도 애초 영상 파일이 큽니다 -> 동영상 재생까지 오래 걸립니다.
	이는 performance 패널을 통해 확인이 가능합니다.
동영상 파일이 54mb인데 이는 웹에서 사용하기엔 영상이 너무 큽니다.

웹페이지에서 영상이 어떻게 불러와져서 표현되는지도 알게 되었고, 문제 상황도 인지하였습니다. 그렇다면 재생까지 오래 걸림 + 크기가 너무 큰 문제를 어떻게 해결해야 할까요?

### 동영상 압축(pg.146)
동영상 압축을 적용합니다. 동영상 압축은 이미지 최적화와 비슷하며, 동영상의 가로와 세로 사이즈를 줄이고, 압축 방식을 변경하여 영상 크기를 줄이는 방식입니다.

### But..
이 작업은 동영상의 화질을 낮추는 작업입니다. 따라서 서비스의 목적에 따라서 사용할지 말지를 선택해야 합니다.

동영상을 WebM으로 변환, (WebM은 WebP와 동일하게 구글에서 개발한 동영상 포맷입니다)
동영상 최적화의 의의는 압축하여 크기를 줄이는데에 있으니 어떤 툴을 사용해도 상관 없으리라 생각했습니다.

 **FFmpeg**라는 동영상 변환 및 압축 도구를 사용해서 명령어로 진행하였습니다.   

### 변환 명령어

```bash

ffmpeg -i banner-video.mp4 -c:v libvpx-vp9 -crf 30 -b:v 0 -b:a 128k -c:a libopus banner-video.webm

```

  ### 사용된 옵션
- `-c:v libvpx-vp9`: VP9 비디오 코덱 사용 (WebM의 최신 코덱)
- `-crf 30`: Constant Rate Factor 30 (품질과 압축률의 균형)
- `-b:v 0`: 비디오 비트레이트를 CRF에 의해 자동 결정
- `-b:a 128k`: 오디오 비트레이트 128kbps
- `-c:a libopus`: Opus 오디오 코덱 사용

### 최적화 결과

| 구분     | 원본 (MP4)  | 최적화 (WebM) | 개선율    |
| ------ | --------- | ---------- | ------ |
| 파일 크기  | 52MB      | 27MB       | 48% 감소 |
| 비디오 코덱 | H.264     | VP9        | -      |
| 오디오 코덱 | -         | Opus       | -      |
| 해상도    | 1920x1080 | 1920x1080  | 동일     |
| 프레임레이트 | 29.97fps  | 29.97fps   | 동일     |

### 패턴과 필터 적용
패턴과 필터를 이용하면 낮은 화질을 조금이나마 보완이 가능하지만, 이는 일종의 착시나 심리적 보완을 이용하는 방법입니다.

---
## 폰트 최적화(pg.151)
웹 페이지에서 사용자 정의 폰트를 사용할 때, 폰트 파일 다운로드에 시간이 소요되어 다음과 같은 문제가 발생할 수 있습니다.

### 문제 상황
웹 폰트 로딩 지연과 사용자 경험 저하


1. **텍스트 깜빡임 (FOUT/FOIT)**
    - 폰트가 로드되기 전까지 기본 폰트로 표시되거나(FOUT), 텍스트가 아예 보이지 않다가(FOIT) 폰트 로드 후 갑자기 나타나는 현상
	    - 이는 사용자에게 페이지가 느리다는 인상을 주거나, 
	    - 레이아웃 변경(Layout Shift)을 유발하여 사용성을 해침
2. **FOUT (Flash of Unstyled Text) 와 FOIT (Flash of Invisible Text)**
    - **FOUT:*
	    - 폰트 다운로드 여부와 관계없이 우선 텍스트를 기본 폰트로 보여주고, 
	    - 폰트 다운로드 완료 시 적용 (Edge 브라우저 방식)
    - **FOIT**
	    - 폰트가 완전히 다운로드될 때까지 텍스트를 보여주지 않음 (Chrome, Safari, Firefox 등)
        - **Chrome의 FOIT**
	        - 3초 동안 폰트 로드를 기다리며, 3초 초과 시 기본 폰트로 우선 표시 후 폰트 다운로드 완료 시 적용

### 폰트 최적화 주요 방법
폰트 최적화는 크게 **폰트 적용 시점 제어**와 **폰트 파일 크기 줄이기** 두 가지 방법으로 나눌 수 있습니다.

#### 1. 폰트 적용 시점 제어
CSS의 `@font-face` 내 `font-display` 속성을 사용하여 폰트 렌더링 방식을 제어할 수 있습니다.

- **`font-display` 속성 값**
    - `auto`
	    - 브라우저 기본 동작 (기본값)
    - `block`
	    - FOIT 방식 (일반적으로 3초 타임아웃)
	    - 텍스트가 보이지 않다가 폰트 로드 후 표시
    - `swap`
	    - FOUT 방식
	    - 기본 폰트로 우선 표시 후 폰트 로드 시 교체
    - `fallback`
	    - 짧은 시간(약 0.1초) 동안 FOIT
		- 실패 시 기본 폰트 사용
		- 이후 폰트가 다운로드되면 다음 방문 시 캐시된 폰트 사용 (첫 로드 시에는 늦게 로드된 폰트 미적용)
    - `optional`
	    - 짧은 시간(약 0.1초) 동안 FOIT
	    - 네트워크 상태에 따라 폰트 적용 여부 결정. 다운로드되지 않으면 기본 폰트 사용, 이후 캐시
- 콘텐츠의 중요도에 따라 적절한 값을 선택해야 합니다. 
	- 예를들어 중요하지 않은 텍스트는 `block` 사용

#### 2. 폰트 파일 크기 줄이기
폰트 파일 크기를 줄여 다운로드 시간을 단축합니다.

- **방법 1: 최신 폰트 포맷 사용**
    - 기존 포맷 (TTF, OTF)은 웹 환경에서 크기가 큼
    - 웹 전용 포맷:
        - **WOFF (Web Open Font Format)** 
	        - TTF를 압축하여 웹 로딩 속도 개선
        - **WOFF2** 
	        - WOFF보다 압축률이 더 향상된 포맷
    - 파일 크기 순서 (큼 → 작음): EOT > TTF/OTF > WOFF > WOFF2
    - **브라우저 호환성** 
	    - 최신 브라우저는 WOFF/WOFF2를 잘 지원
	    - 하지만 하위 호환성을 위해 여러 포맷을 함께 제공하는 것이 좋음 (WOFF2 → WOFF → TTF 순으로 적용)
- **방법 2: 필요한 문자만 포함 (서브세팅)**
    - 폰트 파일에서 실제 사용하는 문자들만 추출하여 파일 크기를 대폭 줄이는 방식
- **방법 3: Data-URI 활용**
    - 폰트 파일을 Base64 등으로 인코딩하여 문자열 형태로 CSS 파일 내에 직접 삽입
    - **장점** 
	    - 폰트를 위한 별도의 HTTP 요청이 발생하지 않아 로딩 속도 개선 (CSS 파일 로드 시 함께 로드됨)

---

## 캐시 최적화(pg.165)

### 문제: 효율적인 캐시 정책의 부재

웹 페이지 로딩 성능 분석 시 "Serve static assets with an efficient cache policy" 항목은 정적 리소스에 캐시 정책이 제대로 적용되지 않았음을 의미합니다. 

개발 서버(`npm run start` 등)는 기본적으로 캐시 설정을 제공하지 않아 응답 헤더에 `Cache-Control` 같은 캐시 관련 헤더가 누락될 수 있습니다.

### 1. 캐시란 무엇인가?
- 자주 사용하는 데이터나 값을 미리 복사해 둔 임시 저장 공간, 또는 그 저장 행위.
- **웹에서의 역할** 
	- 이미지, JS, CSS 파일 등을 최초 요청 시 다운로드하여 캐시에 저장하고, 이후 동일 요청에는 저장된 파일을 사용하여 네트워크 트래픽 감소 및 로딩 속도 향상.
- **웹 캐시의 종류**
    - **메모리 캐시 (Memory Cache)** 
	    - RAM에 저장
	    - 브라우저가 열려있는 동안 매우 빠르게 접근 가능
	    - 탭을 닫거나 브라우저 종료 시 사라짐
    - **디스크 캐시 (Disk Cache)** 
	    - 하드 디스크에 파일 형태로 저장
	    - 브라우저를 종료했다 다시 실행해도 사용 가능
	    - 메모리 캐시보다 느리지만 영속적
    - 어떤 캐시를 사용할지는 브라우저가 자체 알고리즘(사용 빈도, 파일 크기 등)에 따라 결정
    - 개발자 도구 Network 패널의 "Disable cache" 옵션을 해제해야 캐시 동작 확인 가능

### 2. 캐시 제어: `Cache-Control` 헤더
브라우저가 리소스를 캐시하려면 서버 응답 헤더에 `Cache-Control` 헤더가 포함되어 있어야 합니다.

이 헤더는 캐시의 동작 방식과 유효 기간을 지정합니다.

- **주요 지시어(Directives)**
    - `no-store` 
	    - 캐시를 전혀 사용하지 않고 매번 서버에서 리소스를 새로 다운로드
    - `no-cache`
	    - 캐시는 하지만 사용 전 항상 서버에 리소스가 변경되었는지 확인(유효성 검사)
	    - 변경되지 않았으면 캐시 사용 (304 응답)
    - `public`
	    - 공유 캐시(CDN, 프록시 서버) 및 브라우저 자체에 모두 캐시 가능
    - `private`
	    - 브라우저 환경에만 캐시 가능 (사용자 전용)
		- 공유 캐시에는 저장되지 않음
    - `max-age=<seconds>`
	    - 캐시의 유효 시간(초 단위)
		- 이 시간 동안은 서버에 확인 없이 캐시된 리소스를 사용
- **예시**
    - `Cache-Control: max-age=60`
	    - 60초 동안 캐시 사용 (기본적으로 `public`)
    - `Cache-Control: private, max-age=600`
	    - 브라우저 환경에서만 10분 동안 캐시 사용
    - `Cache-Control: public, max-age=0`
	    - 캐시가 즉시 만료
	    - = `no-cache`와 비슷하게 매번 서버에 유효성 확인

### 3. 캐시 적용 및 동작 과정
1. **서버 설정** 
	`Cache-Control` 헤더는 서버에서 응답 시 설정해야 함
	Node.js 서버의 `res.setHeader('Cache-Control', 'max-age=10')`)
2. **유효 기간 내 동작** 
	브라우저는 `max-age`로 지정된 시간 동안 캐시된 리소스를 즉시 사용 (네트워크 요청 없음)
3. **유효 기간 만료 후 동작:**
    - 브라우저는 서버에 캐시된 리소스의 유효성을 확인하기 위해 요청을 보냄
    - 이때, 요청 헤더에 캐시된 리소스의 `ETag` (Entity Tag: 리소스의 특정 버전을 식별하는 고유 문자열) 값을 `If-None-Match` 헤더에 담아 전송
    - **서버의 응답:**
        - **리소스 변경 없음** 
	        - 서버의 현재 리소스 `ETag`와 브라우저가 보낸 `ETag`가 동일하면, 서버는 `304 Not Modified` 상태 코드로 응답 (본문 데이터 없이 헤더만 전송)
	        - 브라우저는 캐시된 리소스를 계속 사용
        - **리소스 변경됨** 
	        - `ETag`가 다르면, 서버는 새로운 리소스와 새로운 `ETag`를 함께 `200 OK` 상태 코드로 응답합니다
		        - 브라우저는 새 리소스를 받고 캐시를 업데이트

### 4. 효율적인 캐시 전략 수립
모든 리소스에 동일한 캐시 정책을 적용하는 것은 비효율적입니다. 
리소스의 변경 빈도와 중요도에 따라 캐시 유효 시간을 다르게 설정해야 합니다.

- **HTML 파일**
    - `Cache-Control: no-cache` (또는 `public, max-age=0`)
    - 항상 최신 버전의 HTML을 받아야 그 안의 JS, CSS 등 다른 리소스 참조가 최신으로 유지됨
- **버전 관리되는 정적 에셋 (JS, CSS 등 - 파일명에 해시 포함)**
    - (예: `main.bb8aac28.chunk.js`)
    - `Cache-Control: public, max-age=31536000` (1년)
    - 내용이 변경되면 파일명(해시) 자체가 바뀌므로, 이전 버전이 잘못 사용될 우려가 없어 매우 긴 캐시 유효 기간 설정 가능
- **이미지 및 기타 정적 파일**
    - 자주 변경되지 않는다면 JS/CSS와 유사하게 긴 `max-age` 설정
    - 변경 가능성이 있다면 적절한 `max-age` 설정 또는 `ETag`를 활용한 유효성 검사 활용

**결론:** 적절한 `Cache-Control` 헤더 설정은 불필요한 네트워크 요청을 줄여 웹사이트 로딩 속도를 크게 향상시키고 사용자 경험을 개선하는 중요한 최적화 방법입니다.

## 불필요한 CSS 제거(pg.176)

### 문제: 사용되지 않는 CSS와 성능 저하

웹 페이지 로딩 성능 분석 시, Lighthouse의 "Reduce unused CSS" 항목이나 개발자 도구의 Coverage 패널은 웹사이트에 사용되지 않는 CSS 코드가 많이 있음을 확인 가능합니다.

1. **진단 도구:**
    - **Lighthouse** 
	    - "Reduce unused CSS" 항목을 통해 사용되지 않는 CSS로 인한 잠재적인 성능 저하를 알려줍니다.
	    - `main.chunk.css` 620KiB 중 616KiB 절감 가능 제시
    - **Coverage 패널** 
	    - 페이지에서 실제로 실행되는 JS 및 CSS 코드의 비율을 시각적으로 보여주어 불필요한 코드의 양을 파악하게 합니다. 
	    - `main.chunk.css`의 99%가 미사용으로 표시
2. **원인**
    - Tailwind CSS 같은 유틸리티 우선 CSS 프레임워크를 사용할 경우, 개발 편의성을 위해 제공되는 수많은 클래스 중 실제 프로덕션 빌드에서는 사용되지 않는 클래스들이 다수 포함되어 있습니다.
	    - 이는 CSS 파일 크기를 증가시킵니다.
3. **JS와 CSS 커버리지의 차이**
    - **JavaScript** 
	    - 조건문(if문 등)으로 인해 초기 로드 시 실행되지 않던 코드도 사용자 인터랙션(페이지 이동, 클릭 등)에 따라 실행되어 커버리지 비율이 증가할 수 있습니다.
    - **CSS** 
	    - 상대적으로 정적이며, 특정 요소나 상태에 대한 스타일이 초기 뷰에 없으면 사용되지 않는 것으로 표시됩니다. 
	    - 따라서 CSS의 높은 미사용률은 더 직접적인 최적화 대상이 될 수 있습니다.

### 해결책: PurgeCSS를 이용한 최적화
사용하지 않는 CSS 코드를 제거하기 위해 **PurgeCSS**라는 도구를 사용할 수 있습니다.

1. **PurgeCSS란?**
    - 지정된 콘텐츠 파일(HTML, JS, 템플릿 파일 등) 내의 모든 텍스트 키워드를 추출합니다.
    - 추출된 키워드를 CSS 클래스 이름과 비교하여, 일치하는 클래스만 보존하고 나머지는 CSS 파일에서 제거합니다.
    - 이를 통해 실제 사용된 스타일만 최종 CSS 파일에 남겨 파일 크기를 최적화합니다.

### 주의사항
특수문자 포함 클래스 처리 (Tailwind CSS 등)

1. **문제 발생 가능**
    - PurgeCSS의 기본 키워드 추출 방식은 콜론(`:`) 같은 특수문자를 포함한 클래스명(예: Tailwind CSS의 `lg:m-8`)을 올바르게 인식하지 못하고 분리된 키워드(`lg`, `m-8`)로 처리할 수 있습니다.
    - 이로 인해 필요한 스타일이 제거되어 화면이 깨지는 현상이 발생합니다.

### 최적화 후 Coverage 패널 이해
- PurgeCSS를 적용하여 불필요한 CSS를 제거했음에도 Coverage 패널에 여전히 사용되지 않는 코드 비율이 높게 나타날 수 있습니다.
- 이는 Coverage 패널은  **현재 페이지 로드 시점에 실제로 실행(적용)된 코드**만을 기준으로 측정합니다.
- 다른 페이지, 반응형 상태 (모바일 뷰), 사용자 인터랙션(호버, 클릭 등)에 의해 동적으로 나타나는 요소의 스타일 등은 초기 로드 시에는 "사용되지 않음"으로 간주될 수 있습니다.
- 사용자가 서비스를 이용하면서 다양한 요소와 상호작용하면 CSS 코드의 실행 비율은 점차 증가합니다.

결론적으로 PurgeCSS는 빌드된 CSS 파일에서 실제로 사용되지 않는 스타일을 효과적으로 제거하여 파일 크기를 줄이고 초기 로딩 성능을 개선하는 데 사용되는 도구입니다. 
