# 4. 이미지 갤러리 최적화

1. 캐시 최적화 (Caching Optimization)
   ✅ 캐시란?
   자주 사용하는 데이터나 값을 미리 복사해 둔 임시 저장 공간 또는 그 저장 동작을 의미합니다.
   초기 요청 시 서버에서 파일을 받아와 저장한 뒤, 이후 동일한 요청에는 해당 캐시된 데이터를 사용함으로써 네트워크 요청을 줄이고 로딩 속도를 향상시킬 수 있습니다.

✅ 캐시의 종류
메모리 캐시 (Memory Cache): 브라우저의 RAM에 저장되며, 접근 속도가 빠르지만 휘발성입니다. 페이지가 리로드되면 사라집니다.

디스크 캐시 (Disk Cache): 브라우저가 하드 디스크에 저장하며, 페이지를 다시 방문했을 때에도 유효할 수 있습니다. 저장 용량이 크고, 영속적입니다.

어떤 캐시를 사용할지는 브라우저가 자동으로 판단합니다. 파일 크기, 접근 빈도, 헤더 설정 등을 기반으로 내부 알고리즘에 따라 처리됩니다.

✅ 캐시 제어: Cache-Control 응답 헤더
서버가 클라이언트에게 캐시 정책을 전달하는 HTTP 헤더입니다.

옵션 설명
no-store 아예 캐시하지 않음. 보안이 중요한 데이터에 사용.
no-cache 캐시된 리소스를 사용하기 전, 서버에 유효성 검사 요청.
public 모든 환경(브라우저, 프록시 서버 등)에서 캐시 가능.
private 사용자 개인 브라우저에만 캐시. 프록시 서버 등에서는 캐시 불가.
max-age=n n초 동안 캐시 유효. 이 시간 동안은 새 요청 없이 캐시 사용.

✅ 최신 리소스 검증: ETag 및 Last-Modified
브라우저는 서버에 요청 시 캐시된 리소스의 ETag 값을 함께 전송합니다.
서버는 현재의 리소스와 비교 후 변경되지 않았다면 304 Not Modified를 반환하여 네트워크 자원을 절약합니다.

2. 불필요한 CSS 제거: PurgeCSS
   ✅ PurgeCSS란?
   사용되지 않는 CSS 코드를 제거하여 최종 번들 파일을 최소화합니다.

HTML, JS, TSX 파일 등에서 실제로 사용된 클래스 이름만 추출하여, 그 외 모든 CSS 선택자는 제거합니다.

✅ 장점
CSS 파일 크기 감소 → 로딩 속도 개선

특히 유틸리티 클래스 기반 프레임워크(Tailwind CSS 등) 사용 시 효과 큼

3. 이미지 지연 로딩 (Lazy Loading)
   ✅ 개념
   초기 렌더링 시 모든 이미지를 불러오는 대신, 뷰포트(화면)에 보일 때 이미지를 불러오는 방식입니다.

✅ 구현 방식
HTML 표준 속성 사용: <img loading="lazy" />

라이브러리 사용: react-lazyload, lazysizes, @loadable/component 등

✅ 효과
초기 로딩 속도 개선

네트워크 자원 절약

UX 향상

4. 레이아웃 이동 방지 (Layout Shift Optimization)
   ✅ 문제
   이미지나 폰트, 동적으로 삽입되는 요소가 로딩되면서 레이아웃이 밀리는 현상 → 사용자 경험에 부정적 영향

✅ 해결 방법
CSS의 aspect-ratio 속성 사용: 이미지의 고정 비율을 미리 설정하여 공간을 확보

```
img {
  aspect-ratio: 16 / 9;
}
width/height 명시적으로 지정
```

폰트 미리 로딩 (font-display: swap)

Skeleton UI 사용

✅ 측정 도구
Lighthouse의 CLS (Cumulative Layout Shift) 지표를 통해 시각적 안정성 확인

✅ CLS 수식 참고
Layout Shift Score = Impact Fraction × Distance Fraction
→ 요소가 이동한 거리와 화면에서 차지하는 비율로 계산

공식 문서: Layout Shift Score

5. 리덕스 렌더링 최적화
   ✅ 문제
   상위 컴포넌트가 Redux 상태를 관찰할 경우, 관련 없는 상태 변경에도 리렌더링이 발생할 수 있음

✅ 해결 방법
useSelector 훅을 통해 정확히 필요한 상태만 구독

값의 실제 변경 여부에 따라 리렌더링 결정됨 (=== 비교)

필요 시 shallowEqual 등을 통해 얕은 비교 수행

`const value = useSelector(state => state.specificValue);`

6. 병목 코드 최적화: 메모이제이션
   ✅ 목적
   컴포넌트나 함수가 불필요하게 다시 실행되지 않도록 방지

✅ 주요 훅
useMemo: 계산 비용이 높은 값을 캐시

useCallback: 함수를 메모이제이션하여 자식 컴포넌트에 동일 참조 유지

React.memo: 컴포넌트를 메모이제이션하여 props 변경 시에만 리렌더링

```ts
const memoizedValue = useMemo(() => computeExpensiveValue(input), [input]);

const memoizedCallback = useCallback(() => {
  doSomething();
}, [dependency]);

const MemoizedComponent = React.memo(MyComponent);
```
